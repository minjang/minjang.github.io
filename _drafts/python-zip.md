---
layout: post
title: ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ìœ¼ë¡œ Pythonì˜ zip ë§Œë“¤ì–´ë³´ê¸°
---
í˜„ëŒ€ C++ë¡œ íŒŒì´ì¬ í‰ë‚´ë‚´ê¸° ì‹œë¦¬ì¦ˆ:

1. [C++11ìœ¼ë¡œ íŒŒì´ì¬ì˜ range í‰ë‚´ë‚´ê¸°](/2015/12/03/python-range-c++11/)
2. [í˜„ëŒ€ C++ë¡œ Pythonì˜ enumerate ë§Œë“¤ì–´ë³´ê¸°](/2016/01/07/python-enumerate-modern-c++/)

ì¼ëŸ¬ë‘ê¸°:

- C++ enumerate ë³´ë‹¤ëŠ” ì•„ë§ˆë„ ì‰½ìŠµë‹ˆë‹¤ ğŸ˜‚
- ì˜ˆì œ ì½”ë“œëŠ” clang 3.6 ì´ìƒì—ì„œ ì œëŒ€ë¡œ ì»´íŒŒì¼ ë©ë‹ˆë‹¤. ë¦¬ëˆ…ìŠ¤ì—ì„œëŠ” libc++ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. Visual Studio 2015 Update 1ì—ì„œëŠ” ì»´íŒŒì¼ì´ ì•ˆ ë˜ëŠ”ë° ìœˆë„ìš°ì—ì„œë„ clangì„ ì„¤ì¹˜í•˜ë©´ ë©ë‹ˆë‹¤. 

ì´ì „ ë‘ ê¸€ì—ì„œ ìœ ë„ ë³€ìˆ˜ ì—†ëŠ” ë£¨í”„ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” íŒŒì´ì¬ê³¼ ìœ ì‚¬í•œ `range`ì™€ `enumerate`ë¥¼ ë§Œë“¤ì—ˆë‹¤. ì´ë²ˆì—ëŠ” íŒŒì´ì¬ì˜ <a href="https://docs.python.org/3/library/functions.html#zip"><code>zip</code></a>ì— í•´ë‹¹í•˜ëŠ” C++ êµ¬í˜„ì„ ë§Œë“¤ê³ ì í•œë‹¤. `zip`ì€ ìˆœíšŒ ê°€ëŠ¥í•œ ê°ì²´ ì—¬ëŸ¬ ê°œë¥¼ ë°›ì•„ ë™ì‹œì— ì´ë“¤ì„ ìˆœíšŒí•  ìˆ˜ ìˆë„ë¡ í•œë‹¤. ì‚¬ìš© ì˜ˆëŠ” ì´ëŸ¬í•˜ë‹¤.

<pre>
<b>zip</b>(<i>*iterables</i>)
</pre>

{% highlight bash %}
$ python3
>>> x = ["e", "p"]
>>> y = [2.718, 3.141]
>>> z = ["foo", "bar", "baz"]
>>> for t in zip(x, y, z):  # tëŠ” tuple íƒ€ì…
...     print("({}, {}, {})".format(t[0], t[1], t[2]))
...
(e, 2.718, foo)
(p, 3.141, bar)
>>>
>>> for i, (t0, t1) in enumerate(zip(x, y)):
...     print("{}: ({}, {})".format(i, t0, t1))
...
0: (e, 2.718)
1: (p, 3.141)
{% endhighlight %}
{% include code_caption.html caption="Python zip ì˜ˆì œ: ì—¬ëŸ¬ ì»¨í…Œì´ë„ˆë¥¼ ë¬¶ì–´ì„œ ë™ì‹œì— ìˆœí™˜í•  ìˆ˜ ìˆë‹¤." %}

íŒŒì´ì¬ì„ ì˜ ëª°ë¼ë„ ì§ê´€ì ìœ¼ë¡œ ì´í•´ê°€ëŠ” ì½”ë“œì´ë‹¤. íŒŒì´ì¬ì˜ `zip`ì€ ë¦¬ìŠ¤íŠ¸ `x`, `y`, `z`ì˜ ì›ì†Œë“¤ë¡œ ì´ë£¨ì–´ì§„ íŠœí”Œ(tuple)ì„ ìˆœí™˜ë§ˆë‹¤ ëŒë ¤ì¤€ë‹¤. `i` ë²ˆì§¸ íŠœí”Œ ì›ì†ŒëŠ” ì—­ì‹œ ì§ê´€ì ìœ¼ë¡œ `zip` í•¨ìˆ˜ì˜ `i` ë²ˆì§¸ ì¸ìˆ˜ì—ì„œ ì–»ì–´ë‚¸ ì›ì†Œì´ë‹¤. íŒŒì´ì¬ì˜ íŠœí”Œì€ ë°°ì—´ì²˜ëŸ¼  ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. ì˜ˆì—ì„œ ë°°ì—´ `z`ì˜ ê¸¸ì´ê°€ ë‹¤ë¥¸ ë°°ì—´ ë³´ë‹¤ ê¸¸ì§€ë§Œ ê°€ì¥ ì§§ì€ ë°°ì—´ì˜ ê¸¸ì´ê¹Œì§€ë§Œ ìˆœí™˜ë˜ì—ˆìŒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì‰½ê²Œ ì˜ˆì¸¡ ê°€ëŠ¥í•œ í–‰ë™ì´ë‹¤.

ë‘ ë²ˆì§¸ ì½”ë“œëŠ” `enumerate`ì™€ ê°™ì´ ì“´ ì˜ˆì œì¸ë° íŠœí”Œì„ ë°”ë¡œ `t0`, `t1` ë³€ìˆ˜ë¡œ í’€ì—ˆë‹¤(unpack). ì´ëŸ° íŠœí”Œì„ ë‚±ê°œ ë³€ìˆ˜ë¡œ í‘¸ëŠ” ì–¸íŒ©ì€ C++ì—ì„œ ì•ˆ ë˜ê² ì§€ë§Œ, í˜„ëŒ€ C++ë¡œ `zip`ê³¼ ê±°ì˜ í¡ì‚¬í•œ ê¸°ëŠ¥ì„ ì—­ì‹œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

ì• ë‘ ê¸€ì—ì„œ í˜„ëŒ€ C++ì˜ ì—¬ëŸ¬ ê¸°ëŠ¥ - ë²”ìœ„ ê¸°ë°˜ for ë£¨í”„, `std::begin/end`, ìš°ì¸¡ê°’ ì°¸ì¡°ì™€ í¬ì›Œë”© ë ˆí¼ëŸ°ìŠ¤, ë¬´ë¸Œ ì‹œë§¨í‹±ê³¼ í¼í™íŠ¸ í¬ì›Œë”© - ì„ ìµœëŒ€í•œ í™œìš©í–ˆë‹¤. ì´ë²ˆ ê¸€ì€ C++11ì— ì¶”ê°€ëœ ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿, variadic templateì„ ì“¸ ê²ƒì´ë‹¤. ë” ë‚˜ê°€ C++14ì—ì„œ ì„  ë³´ì¸ `decltype(auto)`, C++17ì— ë„ì…ëœ í¬í•œí•œ ë¬¸ë²•ë„ í™œìš©í•œë‹¤.

### 1. C++ zip ìš”êµ¬ì¡°ê±´ ì •í•˜ê¸°
C++ë¡œ `zip`ì„ ë§Œë“ ë‹¤ë©´ ì•„ë§ˆ ì´ë ‡ê²Œ ë§Œë“¤ì–´ ì“¸ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. ê·¸ ê²°ê³¼ëŠ” ì½”ë“œ 1ì˜ íŒŒì´ì¬ ì˜ˆì™€ ê°™ì„ ê²ƒì´ë‹¤.

{% highlight C++ linenos=table%}
vector<string> x = {"e", "p"};
vector<double> y = {2.718, 3.141};
vector<string> z = {"foo", "bar", "baz"};
// for (auto&& t : zip(x, y, z)) ë˜ëŠ”
for (std::tuple<string&, double&, string&> t : zip(x, y, z))
  cout << "(" << get<0>(t) << ", " << get<1>(t) << ", " << get<2>(t) << ")\n";
// for (auto&& p : enumerate(zip(x, y))) ë˜ëŠ”
for (pair<size_t, tuple<string&, double&>> &&p : enumerate(zip(x, y)))
  cout << p.first << ": (" << get<0>(p.second) << ", " << get<1>(p.second) << ")\n";
{% endhighlight %}
{% include code_caption.html caption="íŒŒì´ì¬ ì½”ë“œ ì˜ˆë¥¼ C++ë¡œ ì“´ë‹¤ë©´ ì•„ë§ˆ ì´ë ‡ê²Œ?" %}

íŒŒì´ì¬ê³¼ ë¹„ìŠ·í•˜ê²Œ ìˆœí™˜ë§ˆë‹¤ ì›ì†Œ ì°¸ì¡°ì(ë˜ëŠ” ì›ì†Œ ê°’[^element])ë“¤ì˜ íŠœí”Œì„ ëŒë ¤ì£¼ë„ë¡ ë§Œë“¤ ê²ƒì´ë‹¤.
C++11ë¶€í„° <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>ì´ ì§€ì›ëœë‹¤. C++ íŠœí”Œì€ ë‘ íƒ€ì…ë§Œ ê°€ì§ˆ ìˆ˜ ìˆì—ˆë˜ `std::pair`ë¥¼ ì¼ë°˜í™”í•œ ê²ƒìœ¼ë¡œ ë¯¸ë¦¬ ì •í•´ì§„ ê°œìˆ˜ ë§Œí¼ì˜ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§€ëŠ” í…œí”Œë¦¿ í´ë˜ìŠ¤ì´ë‹¤.

[^element]: [ì• ê¸€](/2016/01/07/python-enumerate-modern-c++/#detail1)ì—ì„œ ì„¤ëª…í–ˆë“¯ì´ ì •í™•í•˜ê²ŒëŠ” "ì»¨í…Œì´ë„ˆ ë°˜ë³µìì˜ `*` ì—°ì‚°ìê°€ ëŒë ¤ì£¼ëŠ” íƒ€ì…"ì´ì§€ë§Œ ê·¸ëƒ¥ ì°¸ì¡°ìë¡œ ê°€ì •í•  ê²ƒì´ë‹¤. ê°’ì´ë¼ê³  í•´ë„ ë³µì‚¬ê°€ ê°€ë²¼ìš´ ê°’ì´ì¼í…Œë‹ˆ.

ì½”ë“œ 2ì˜ ë¼ì¸ 5ë¥¼ ë³´ë©´ `tuple<string&, double&, string&>`ìœ¼ë¡œ ì„ ì–¸í–ˆë‹¤. C++ íŠœí”Œì€ ì»´íŒŒì¼ ì‹œê°„ì— ê·¸ í¬ê¸°ê°€ ê²°ì •ë˜ëŠ” í…œí”Œë¦¿ ê¸°ë°˜ ìë£Œêµ¬ì¡°ë¼ì„œ ë°°ì—´ ì²˜ëŸ¼ ì ‘ê·¼ì´ ì•ˆ ëœë‹¤. ì˜ˆì œì—ì„œ ë³´ë‹¤ì‹œí”¼ <a href="http://en.cppreference.com/w/cpp/utility/tuple/get"><code>std::get<0>(t)</code></a> ê°™ì€ ì¢€ ëª» ìƒê¸´ ë¬¸ë²•ìœ¼ë¡œ íŠœí”Œ ê°’ì„ ì½ì–´ì•¼ í•œë‹¤. `get<index>`ì—ì„œ `index`ëŠ” ë°˜ë“œì‹œ ìƒìˆ˜ ê°’ì´ ë˜ì–´ì•¼ í•œë‹¤. ë°°ì—´ì²˜ëŸ¼ ë£¨í”„ì—ì„œ ì¸ë±ìŠ¤ ë³€ìˆ˜ë¥¼ ì´ìš©í•˜ëŠ” ì½”ë“œëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜ì´ë‹¤. ë’¤ì—ì„œ ì‚´í´ë³´ê² ì§€ë§Œ ëª¨ë“  íŠœí”Œ ì›ì†Œë¥¼ ìˆœíšŒí•˜ë©° ì‘ì—…ì„ í•˜ë ¤ë©´ ëª‡ ê°€ì§€ í…Œí¬ë‹‰ì´ í•„ìš”í•˜ë‹¤.

C++ `zip`ì´ ë°›ì„ ìˆ˜ ìˆëŠ” ì»¨í…Œì´ë„ˆ íƒ€ì…ì€ ì• ê¸€ì—ì„œ ì„¤ëª…í•œ `enumerate`ì™€ ê±°ì˜ ê°™ë‹¤. ë²”ìœ„ ê¸°ë°˜ for ë£¨í”„ê°€ ë°›ì„ ìˆ˜ ìˆëŠ” ëª¨ë“  ê²ƒ: (1) STL ì»¨í…Œì´ë„ˆ, (2) ì¼ë°˜ ë°°ì—´, (3) `begin`/`end` ë©”ì„œë“œë¥¼ ë…¸ì¶œí•˜ëŠ” ì‚¬ìš©ì ì»¨í…Œì´ë„ˆë¥¼ `zip`ì—ì„œë„ ì“¸ ìˆ˜ ìˆë‹¤. ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ëŠ” ì¢€ ê³¨ì¹˜ ì•„í”„ë‹¤. ì´ê²ƒë§Œ ë¬´ì‹œí•˜ë©´ `enumerate`ê°€ ë°›ì„ ìˆ˜ ìˆëŠ” ê²ƒì„ ëª¨ë‘ `zip`ì—ì„œ ì“¸ ìˆ˜ ìˆë‹¤.

íŒŒì´ì¬ì˜ `zip`ì´ ê°€ë³€ ì¸ìˆ˜ë¥¼ ë°›ë“¯ì´ C++ `zip` ë˜í•œ ê°€ë³€ ì¸ìˆ˜ë¥¼ í—ˆìš©í•œë‹¤. êµ¬í˜„ì€ `printf`ì—ì„œ ë³´ì•„ì™”ë˜ ì•ˆì „í•˜ì§€ ì•Šì€ C ê¸°ë°˜ì˜ [ê°€ë³€ ì¸ìˆ˜](http://en.cppreference.com/w/cpp/language/variadic_arguments)ê°€ ì•„ë‹Œ C++11ë¶€í„° ì¶”ê°€ëœ [ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿(variadic template)](http://en.cppreference.com/w/cpp/language/parameter_pack)ì„ ì“´ë‹¤.[^variadic]

[^variadic]: Variadicì„ ê°€ë³€ *ì¸ì*ë¡œ ë²ˆì—­í•˜ê¸°ë„ í•˜ëŠ”ë° ê°€ë³€ ì¸ìˆ˜ë¡œ ë³´ëŠ” ê²ƒì´ ë” íƒ€ë‹¹í•˜ë‹¤. ì¼ë‹¨, í•¨ìˆ˜ `f(int x)`ê°€ ìˆë‹¤ë©´ `x`ëŠ” í•¨ìˆ˜ `f`ì˜ *ì¸ì*, *parameter*ì´ë‹¤. ì´ í•¨ìˆ˜ë¥¼ `f(42)`ì²˜ëŸ¼ ë¶€ë¥¼ ë•Œ 42ëŠ” ì´ í•¨ìˆ˜ì˜ *ì¸ìˆ˜*, *argument*ì´ë‹¤. ì¸ìì™€ ì¸ìˆ˜ì— ëŒ€í•œ ë²ˆì—­ì—ëŠ” í•©ì˜ê°€ ìˆëŠ” í¸ì´ë‹¤. Variadicì€ ê°€ë³€ì ì¸ *argument*ë¥¼ ë°›ëŠ”ë‹¤ê³  [ë³´í†µ ì •ì˜ëœë‹¤](https://en.wikipedia.org/wiki/Variadic_function). ë”°ë¼ì„œ variadic templateë„ ê°€ë³€ *ì¸ìˆ˜* í…œí”Œë¦¿ìœ¼ë¡œ ë²ˆì—­í•˜ëŠ” ê²ƒì´ ì˜³ë‹¤. í…œí”Œë¦¿ì„ ì“°ëŠ” ì…ì¥ì—ì„œ ê°€ë³€ì ì¸ ì¸ìˆ˜ë¥¼ ë„£ì–´ì£¼ë‹ˆ ë§ëŠ” ë§ì´ë‹¤. ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ê³¼ ìì£¼ ë“±ì¥í•˜ëŠ” ìš©ì–´ê°€ parameter pack, ì¸ì ë¬¶ìŒì´ë‹¤. ì´ê²ƒì€ ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ë¥¼ ì‹¤ì œë¡œ êµ¬í˜„í•  ë•Œ ë‹¤ë£¨ëŠ” ê²ƒìœ¼ë¡œ í•¨ìˆ˜ ë‚´ì—ì„œ ë³´ëŠ” ê²ƒì€ ì´ì œ ì¸ìê°€ ë˜ê¸° ë–„ë¬¸ì´ë‹¤. Variadic templateì„ ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ìœ¼ë¡œ ë²ˆì—­í•˜ëŠ” ìª½ì´ ë” ì¼ê´€ì„±ì´ ë†’ë‹¤.

ì •ë¦¬í•˜ë©´ C++ `zip`ì˜ ìš”êµ¬ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

- ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ìœ¼ë¡œ êµ¬í˜„.
- `std::tuple`ë¡œ ì…ë ¥ ì»¨í…Œì´ë„ˆë“¤ì˜ ì›ì†Œ ì§‘í•©ì„ ë°›ëŠ”ë‹¤.
- ë²”ìœ„ ê¸°ë°˜ for ë£¨í”„ ë˜ëŠ” C++ `enumerate`ê°€ ë°›ì„ ìˆ˜ ìˆëŠ” ì»¨í…Œì´ë„ˆëŠ” ë°›ì„ ìˆ˜ ìˆë‹¤. ë‹¨, ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ëŠ” ë‚˜ì¤‘ì— ê³ ë ¤í•˜ê¸°ë¡œ í•œë‹¤.

ë³„ ë‚´ìš© ì—†ë‹¤. ê·¸ëƒ¥ ê°€ë³€ ì¸ìˆ˜ì™€ íŠœí”Œì„ ì“°ê² ë‹¤ëŠ” ê²ƒì´ë‹¤.


### 2. í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

`enumerate`ì—ì„œ ì´ë¯¸ ìƒìˆ˜, ì¼ë°˜ ë°°ì—´ ë“±ì€ ìì„¸íˆ ë‹¤ë¤˜ìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì¶•ì•½ëœ í…ŒìŠ¤íŠ¸ë§Œ ë§Œë“¤ì. ì•ì—ì„œ ë§Œë“  `range`, `enumerate`ì™€ í”„ë½ì‹œ ë°˜ë³µì(proxy iterator)ë¥¼ ì“°ëŠ” `vector<bool>`ë„ í…ŒìŠ¤íŠ¸ì— ì¶”ê°€í•œë‹¤. í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì™€ ì˜ˆìƒ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 

{% highlight C++ linenos=table%}
vector<bool> A   = {   false,    false,  true};
size_t B[]       = { 0, 0, 0, 0}; // ê¸¸ì´ê°€ ë‹¤ë¦„
vector<string> C = {    "pi",      "e", "ans"};
const double D[] = {3.141592, 2.718281,    42};

cout << std::boolalpha;

// ì„ì˜ì˜ tuple/pairê°€ coutìœ¼ë¡œ ì¶œë ¥ë˜ë„ë¡ ë§Œë“¤ì—ˆë‹¤ê³  ê°€ì •
// pair<t1, t2>
//  => cout << "<" << t1 << ", " << t2 << ">"
// tuple<t1, t2, ..., tn>
//  => cout << "(" << t1 << ", " << ... << ")";

// A, B, CëŠ” ìˆ˜ì • ê°€ëŠ¥, rangeë„ ê°™ì´ ì‚¬ìš©
// std::sizeëŠ” C++1z/17ë¶€í„° ì§€ì›
// decltype(t) == tuple<proxy, size_t&, string&, size_t>&&
for (auto&& t : zip(A, B, C, range<size_t>(0, std::size(A)))) {
  cout << "Before: " << t << endl;
  get<0>(t) = get<0>(t) ^ true;
  get<1>(t) = get<3>(t);
  get<2>(t) = '\"' + get<2>(t) + '\"';
}

// enumerateì™€ ê°™ì´ ì‚¬ìš©
// decltype(p) == pair<size_t,
//   tuple<proxy, size_t&, string&, const double&>>&&
for (auto&& p : enumerate(zip(A, B, C, D))) {
  cout << "After: " << p << endl;
}

// zip, enumerate, range ëª¨ë‘ ê°™ì´ ì‚¬ìš©
// decltype(t) == tuple<pair<size_t, int>>&&
for (auto&& t : zip(enumerate(range(11, 14)))) {
  cout << t << endl;
}
{% endhighlight %}

{% highlight bash %}
Before: (false, 0, pi, 0)
Before: (false, 0, e, 1)
Before: (true, 0, ans, 2)
After: <0, (true, 0, "pi", 3.14159)>
After: <1, (true, 1, "e", 2.71828)>
After: <2, (false, 2, "ans", 42)>
(<0, 11>)
(<1, 12>)
(<2, 13>)
{% endhighlight %}
{% include code_caption.html caption="C++ <code>zip</code> í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì™€ ì˜ˆìƒ ê²°ê³¼" %}

íŠœí”Œ ì¶œë ¥ ì½”ë“œë¥¼ ìƒëµí•˜ê³ ì `std::pair`ì™€ `std::tuple`ì„ `cout`ìœ¼ë¡œ ì¶œë ¥í•˜ëŠ” ì½”ë“œê°€ ìˆë‹¤ê³  ê°€ì •í•œë‹¤. ë’¤ì—ì„œ ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ì„ ì„¤ëª…í•˜ë©´ì„œ ì´ ì½”ë“œë¥¼ ë°°ìš¸ ê²ƒì´ë‹¤.

íŠœí”Œ ì›ì†Œ ê°’ì„ ë³€ê²½í•  ë•ŒëŠ” ë³„ë„ë¡œ `set` ê°™ì€ í•¨ìˆ˜ë¡œ í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ `std::get`ì´ ì°¸ì¡°ìë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ ë°”ë¡œ ì—¬ê¸°ì—ë‹¤ ì“°ë©´ ëœë‹¤. ë³´ë‹¤ì‹œí”¼ ìƒìˆ˜ ë°°ì—´ì´ ì•„ë‹Œ ì´ìƒ ê°’ì„ ë°”ê¿€ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.

ì£¼ëª©í•  ê²ƒì€ `vector<bool>`, `range`, `enumerate`ì˜ ì‚¬ìš© ì˜ˆì´ë‹¤. `vector<string>`ì„ ë²”ìœ„ ê¸°ë°˜ for ë£¨í”„ë‚˜ `enumerate`ì— ë„£ìœ¼ë©´ ìˆœí™˜ë§ˆë‹¤ ì–»ëŠ” ì›ì†Œê°€ `string&` ì°¸ì¡°ì í˜•íƒœì´ë‹¤. ê·¸ëŸ¬ë‚˜ `vector<bool>`ì€ `bool&`ì´ ì•„ë‹Œ ë³„ë„ì˜ ê°ì²´, í”„ë½ì‹œ(proxy, ëŒ€ë¦¬ì) ë°˜ë³µìë¥¼ ë§Œë“¤ì–´ ê°’ìœ¼ë¡œ ë°˜í™˜ëœë‹¤. `bool`ì€ 1ë¹„íŠ¸ë§Œ ìˆì–´ë„ ë˜ë¯€ë¡œ 1 ë°”ì´íŠ¸ì— ì—¬ëŸ¬ `bool` ê°’ì„ ëª¨ì•„ ì €ì¥í•œë‹¤. ê·¸ë˜ì„œ ë°”ë¡œ `bool&`ì„ ë°˜í™˜í•  ìˆ˜ ì—†ê³  í”„ë½ì‹œ ë°˜ë³µìë¥¼ ì„ì‹œë¡œ ë§Œë“¤ì–´ ë°˜í™˜í•œë‹¤. ì„ì‹œ ê°’ì´ë¯€ë¡œ ì´ê²ƒì„ (ë¹„ìƒìˆ˜) ì°¸ì¡°ìë¡œëŠ” ë°˜í™˜í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê°’ìœ¼ë¡œ ëŒë ¤ì¤€ë‹¤. ì‹¤ì œ ë¼ì¸ 17ì˜ íŠœí”Œ íƒ€ì…ì„ ë””ë²„ê±°ë‚˜ boostì˜ `type_id_with_cvr`ë¡œ í™•ì¸í•˜ë©´ `bool&` ëŒ€ì‹  ë‚´ë¶€ êµ¬í˜„ì²´ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.

`range`ë„ í”„ë½ì‹œ ë°˜ë³µìë¥¼ ì“°ëŠ”ì…ˆì´ë‹¤. ë£¨í”„ì—ì„œ `size_t&` ì°¸ì¡°ì í˜•íƒœë¡œ ì›ì†Œë¥¼ ì–»ì§€ ì•Šì•˜ë‹¤. `range_iterator`ê°€ ìˆœí™˜ë§ˆë‹¤ ë§Œë“¤ì–´ì§€ê³  ì—¬ê¸°ì„œ `size_t`ë¥¼ ë°”ë¡œ ê°’ìœ¼ë¡œ ë°˜í™˜í–ˆë‹¤. ë¼ì¸ 33ì˜ `enumerate`ë„ ë§ˆì°¬ê°€ì§€ì´ë‹¤. `pair<size_t, int>`ë¥¼ ì¦‰ì„ì—ì„œ ë§Œë“  ë’¤ ê°’ìœ¼ë¡œ ëŒë ¤ì£¼ë¯€ë¡œ í”„ë½ì‹œ ë°˜ë³µì êµ¬ì¡°ì´ë‹¤. ì™œ ì´ ì´ì•¼ê¸°ë¥¼ í•˜ëƒë©´, `zip` êµ¬í˜„ì‹œ ì‘ì€ íƒ€ì… ìºìŠ¤íŒ… ì‹¤ìˆ˜ë¥¼ í•œë‹¤ë©´ í”„ë½ì‹œ ë°˜ë³µìë¥¼ ì œëŒ€ë¡œ ë‹¤ë£° ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.


### 3. ë‘ ì»¨í…Œì´ë„ˆë§Œ ë°›ì„ ìˆ˜ ìˆëŠ” `zip`ì„ ë§Œë“¤ê¸°

ë°”ë¡œ ê°€ë³€ ì¸ìˆ˜ë¥¼ ë°›ëŠ” `zip`ì€ ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿ì— ëŠ¥ìˆ™í•˜ì§€ ì•Šì€ ì´ìƒ ì–´ë µë‹¤. ë‘ ì»¨í…Œì´ë„ˆë§Œ ë°›ì„ ìˆ˜ ìˆëŠ” `zip`ì„ ë¨¼ì € ë§Œë“¤ê³  ì´ë¥¼ ê°€ë³€ ì¸ìˆ˜ í…œí”Œë¦¿í™”í•˜ëŠ” ê²ƒì´ ì¢‹ì„ ê²ƒì´ë‹¤. `zip` êµ¬í˜„ì€ ì•ì„œ ë§Œë“  `enumerate`ì™€ ê°™ì€ êµ¬ì¡°ì´ê³  ì½”ë“œë„ ê°„ë‹¨í•˜ë‹¤. ì• ê¸€ì—ì„œ í˜ë“¤ê²Œ ì„¤ëª…í–ˆë˜ í¬ì›Œë”© ë ˆí¼ëŸ°ìŠ¤, `decltype`, `std::declval` ë“±ì„ ê·¸ëŒ€ë¡œ í™œìš©í•œë‹¤. `zip`ê³¼ `zip_impl` êµ¬í˜„ì€ ì´ë ‡ê²Œ í•  ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.

{% highlight C++ linenos=table%}
template<typename C1, typename C2>
zip_impl<C1, C2> zip(C1&& c1, C2&& c2) {
  return {std::forward<C1>(c1), std::forward<C2>(c2)};
}
{% endhighlight %}
{% include code_caption.html caption="ë‘ ì»¨í…Œì´ë„ˆë§Œ ë°›ëŠ” <code>zip</code> êµ¬í˜„" %}

ë‘ ì…ë ¥ ì»¨í…Œì´ë„ˆë¥¼ ë°›ì„ ë•Œ ì¢Œì¸¡ê°’ê³¼ ìš°ì¸¡ê°’ì„ ëª¨ë‘ ë°›ì„ ìˆ˜ ìˆëŠ” í¬ì›Œë”© ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì¼ê³  `std::forward`ë¡œ `zip_impl` ìƒì„±ìë¡œ ì´ ê°’ì„ ì™„ë²½í•˜ê²Œ ì „ë‹¬í•œë‹¤.

{% highlight C++ linenos=table%}
template<typename C1, typename C2>
class zip_impl {
  std::tuple<C1, C2> containers_;

public:
  zip_impl(C1&& c1, C2&& c2) : 
    containers_{std::forward<C1>(c1), std::forward<C2>(c2)} {}

  zip_iterator<C1, C2> begin() {
    return {std::begin(std::get<0>(containers_)),
            std::begin(std::get<1>(containers_))};
  }

  zip_iterator<C1, C2> end() {
    return {std::end(std::get<0>(containers_)),
            std::end(std::get<1>(containers_))};
  }
};
{% endhighlight %}
{% include code_caption.html caption="ë‘ ì»¨í…Œì´ë„ˆë§Œ ë°›ëŠ” <code>zip_impl</code> êµ¬í˜„" %}

`zip_impl`ì€ ì…ë ¥ ì»¨í…Œì´ë„ˆë“¤ì„ íŠœí”Œë¡œ ë³´ê´€í•˜ê³  `std::begin/end`ë¥¼ ì¨ì„œ `zip_iterator`ë¥¼ ë§Œë“ ë‹¤. ì§€ê¸ˆì€ ì´ ì½”ë“œê°€ ê°„ë‹¨í•´ ë³´ì´ì§€ë§Œ ìˆ¨ì–´ìˆëŠ” ë””í…Œì¼ì´ ì–´ë§ˆì–´ë§ˆí–ˆë‹¤.

{% highlight C++ linenos=table%}
template<typename C1, typename C2>
class zip_iterator {
  using IterType1 = decltype(std::begin(std::declval<C1&>()));
  using IterType2 = decltype(std::begin(std::declval<C2&>()));
  using ElemType1 = decltype(*std::begin(std::declval<C1&>()));
  using ElemType2 = decltype(*std::begin(std::declval<C2&>()));
  
  using TupleType = std::tuple<ElemType1, ElemType2>;

  std::tuple<IterType1, IterType2> its_;

public:
  zip_iterator(IterType1 it1, IterType2 it2) : its_{it1, it2} {}

  zip_iterator& operator++() {
    ++std::get<0>(its_);
    ++std::get<1>(its_);
    return *this;
  }

  bool operator!=(const zip_iterator& rhs) {
    return std::get<0>(its_) != std::get<0>(rhs.its_) &&
           std::get<1>(its_) != std::get<1>(rhs.its_);
  }

  TupleType operator*() {
    // ë  ê²ƒ ê°™ì€ë° ì»´íŒŒì¼ ì˜¤ë¥˜. std::pairëŠ” ë¨.
    return {*std::get<0>(its_), *std::get<1>(its_)};
  }  
};
{% endhighlight %}
{% include code_caption.html caption="ë‘ ì»¨í…Œì´ë„ˆë§Œ ë°›ëŠ” <code>zip_iterator</code> êµ¬í˜„: ì»´íŒŒì¼ ì˜¤ë¥˜ ìˆìŒ" %}

`zip_iterator`ëŠ” `enumerate_iterator`ì™€ [ì•„ì£¼ ë¹„ìŠ·í•˜ë‹¤](https://github.com/minjang/minjang.github.io/blob/master/assets/2016/python_like_enumerate/python_like.cpp#L63). ë‹¤ë§Œ `IterType`ê³¼ `ElemType`ì´ ì»¨í…Œì´ë„ˆ ë‘ ê°œì— ëŒ€í•´ ê°ê° í•„ìš”í•˜ê³ , `PairType` ëŒ€ì‹  `TupleType`ì„ ë§Œë“¤ì—ˆë‹¤. ë°˜ë³µìë„ ë‘ ê°œë¥¼ ì €ì¥í•´ì•¼ í•˜ë¯€ë¡œ íŠœí”Œì„ ì¼ë‹¤. `!=` ì—°ì‚°ìëŠ” ë‘˜ ì¤‘ì˜ ë” ì§§ì€ ì»¨í…Œì´ë„ˆ ê¸¸ì´ì—ì„œ ì¢…ë£Œê°€ ë˜ë„ë¡ í•˜ë©´ ëœë‹¤. ì—¬ê¸°ê¹Œì§„ ìˆœì¡°ë¡­ê²Œ ì§„í–‰ëœë‹¤.

ê·¸ëŸ°ë° ì´ë ‡ê²Œ ì‰½ê²Œ ì™„ì„±ë ë¦¬ê°€ ì—†ë‹¤.

ë¼ì¸ 26ì˜ `operator*`ëŠ” ì›ì†Œ ì°¸ì¡°ì/ê°’ë“¤ì„ ëª¨ì•„ `std::tuple` íƒ€ì…ìœ¼ë¡œ ë§Œë“¤ë ¤ëŠ” ì‹œë„ì´ë‹¤. `enumerate` êµ¬í˜„ì—ì„œ ë³´ì•˜ë“¯ì´ `std::pair`ì˜ ìƒì„±ì€ `{...}`ë¡œ ì˜ ë˜ì—ˆë‹¤. ì•ˆíƒ€ê¹ê²Œë„ ì´ ê¸€ì„ ì“°ëŠ” ì‹œì ì—ì„œ ìµœì‹ ì¸ clang 3.8 ê¸°ì¤€ìœ¼ë¡œë„ `std::tuple`ì€ `std::pair`ì²˜ëŸ¼ `{...}`ë¡œ ìƒì„±í•  ìˆ˜ ì—†ë‹¤. ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ë¥¼ ë³´ë©´ copy-initialization ìƒí™©ì—ì„œ ì„ íƒëœ ìƒì„±ìê°€ `explicit`ì´ë¼ê³  í•œë‹¤. [ì—¬ê¸° ì˜ˆ](http://en.cppreference.com/w/cpp/language/explicit)ë¥¼ ë³´ë©´ ì´ ì—ëŸ¬ë¥¼ ì´í•´í•˜ëŠ”ë°  ë„ì›€ì´ ëœë‹¤.

ë‹¤í–‰íˆ ì´ ë¬¸ì œëŠ” C++ ìœ„ì›íšŒì—ì„œë„ ë¬¸ì œë¡œ ì œê¸°ë˜ì–´ C++17ì—ì„œ ê³ ì³ì§ˆ ì˜ˆì •ì´ë‹¤. ì´ ë¬¸ì œë¥¼ ë‹¤ë£¬ [n4387 ë¬¸ì„œ](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html)ë¥¼ ë³´ë©´ ìì„¸í•œ ì„¤ëª…ì´ ìˆìœ¼ë‚˜ ì œëŒ€ë¡œ ì´í•´í•˜ê¸°ëŠ” ì–´ë µë‹¤. ëŒ€ëµ ë³´ë‹ˆê¹Œ `tuple` êµ¬í˜„ì—ì„œ ë‹¤ì†Œ ì‹¤ìˆ˜í•œ ì ì´ ìˆë‹¤ê³  í•œë‹¤. 

{% highlight C++ linenos=table%}
std::tuple<int, int> foo_tuple() {
  return {1, -1};           // ì—ëŸ¬: C++17 ë¶€í„° ì§€ì›ë¨
  return make_tuple(1, -1); // í•­ìƒ ë¨
  
  std::tuple<int, int> t{1, -1}; // ì´ê²ƒë„ ì˜ ë¨
  return t;
}
std::pair<int, int> foo_pair() {
  return {1, -1};  // OK
}
{% endhighlight %}
{% include code_caption.html caption="C++14ê¹Œì§€ëŠ” <code>tuple</code>ì„ <code>pair</code>ì²˜ëŸ¼ ê°„í¸í•˜ê²Œ ìƒì„±í•  ìˆ˜ ì—†ìŒ" %}

ì½”ë“œ 7ì— `pair`ì™€ `tuple`ì˜ ìƒì„± ë°©ë²• ì°¨ì´ê°€ ì˜ ë‚˜íƒ€ìˆë‹¤. íŠœí”Œì„ ì¤‘ê´„í˜¸(brace)ë¡œ ì´ˆê¸°í™” í•˜ëŠ” ê²ƒì´ C++14ì—ì„œ ì•ˆ ë˜ë¯€ë¡œ `make_pair`ë¥¼ ë¶€ë¥´ê±°ë‚˜ ë¡œì»¬ì—ì„œ ë§Œë“  ë’¤ ë°˜í™˜í•˜ëŠ” ë°©ë²•ì„ ì¨ì•¼í•œë‹¤. ì§€ì—­ ë³€ìˆ˜ ì“°ëŠ” ê²ƒë„ ë³„ë¡œ ì˜ˆì˜ì§€ ì•Šìœ¼ë‹ˆ `make_tuple`ë¥¼ ì¨ë³´ì.

{% highlight C++ %}
TupleType operator*() {
  // ìƒìˆ˜ ì»¨í…Œì´ë„ˆë‚˜ í”„ë½ì‹œ ë°˜ë³µìë¥¼ ì“°ëŠ” ì»¨í…Œì´ë„ˆë§Œ ì»´íŒŒì¼ ë¨.
  // ì¼ë°˜ ì»¨í…Œì´ë„ˆëŠ” ì›ì†Œ ì°¸ì¡°ìë¡œ ìºìŠ¤íŒ… ì•ˆ ëœë‹¤ëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜.
  return std::make_tuple(*std::get<0>(its_), *std::get<1>(its_));
}
{% endhighlight %}
{% include code_caption.html caption="<code>make_tuple</code>ì€ decayëœ íƒ€ì…ìœ¼ë¡œ íŠœí”Œ ìƒì„±" %}

ê·¸ëŸ°ë° ì´ê²ƒë„ ì»´íŒŒì¼ì´ ì•ˆ ëœë‹¤. ì •í™•í•˜ê²Œ ë§í•˜ìë©´, ìƒìˆ˜ ì»¨í…Œì´ë„ˆë‚˜ í”„ë½ì‹œ ë°˜ë³µìë¥¼ ì“°ëŠ” ì»¨í…Œì´ë„ˆë§Œ ì»´íŒŒì¼ì´ ë˜ì§€ë§Œ, ê·¸ ì™¸ëŠ” `make_tuple`ì˜ ê²°ê³¼ íƒ€ì…ì„ `TupleType`ìœ¼ë¡œ ìºìŠ¤íŒ… í•  ìˆ˜ ì—†ë‹¤ëŠ” ì˜¤ë¥˜ê°€ ë‚œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `vector<int>` ë‘ ê°œë¥¼ `zip`ì— ë„£ì—ˆì„ ë•Œ `TupleType`ì€ `tuple<int&, int&>`ì´ë‹¤. í•˜ì§€ë§Œ `make_tuple`ì—ì„œ ì–»ì–´ì§€ëŠ” íƒ€ì…ì„ ì¡°ì‚¬í•˜ë©´ `tuple<int, int>`ë¡œì„œ ì°¸ì¡°ìê°€ ì‚¬ë¼ì§„ í˜•íƒœì´ë‹¤. ì™œ ê·¸ëŸ´ê¹Œ?
`make_tuple`ì˜ [ì„¤ëª…](http://en.cppreference.com/w/cpp/utility/tuple/make_tuple)ì— ë”°ë¥´ë©´ ì£¼ì–´ì§„ íƒ€ì…ì„ ê·¸ëŒ€ë¡œ ëª¨ì•„ íŠœí”Œë¡œ ë§Œë“¤ì§€ ì•Šê³ , `std::decay`ë¡œ í•œë²ˆ ê°€ê³µì„ í•œ ë’¤ íŠœí”Œì„ ë§Œë“ ë‹¤..

`std::decay`ëŠ”[^decay] ì£¼ì–´ì§„ íƒ€ì…ì—ì„œ ì°¸ì¡°ì ê¸°í˜¸ê°€ ìˆë‹¤ë©´ ë¨¼ì € ëª¨ë‘ ì œê±°í•œë‹¤. ê·¸ ë’¤ íƒ€ì…ì˜ ì„±ê²©ì— ë”°ë¼ ë°°ì—´ì€ í¬ì¸í„°ë¡œ, í•¨ìˆ˜ëŠ” í•¨ìˆ˜ í¬ì¸í„°ë¡œ, ì¼ë°˜ íƒ€ì…ì€ cv í•œì •ìë¥¼ ì—†ì•¤ë‹¤. ê·¸ë˜ì„œ ì°¸ì¡°ìê°€ ì‚¬ë¼ì§„ ê²ƒì´ë‹¤.

[^decay]: Decayì˜ ì¼ë°˜ì ì¸ ì˜ì–´ ëœ»ì€ ì©ë‹¤/ë¶•ê´´ ê°™ì€ ëœ»ìœ¼ë¡œ ì“°ì´ëŠ”ë°, ì´ ë¬¸ë§¥ì—ì„œëŠ” íƒ€ì…ì„ "ì•½í•˜ê²Œ í•œë‹¤"ëŠ” ëœ»ìœ¼ë¡œ ë°›ì•„ë“¤ì´ë©´ ì¢‹ë‹¤. ì›ë˜ íƒ€ì…ì€ ë” ë§ì€ ì •ë³´, íŠ¹íˆ ë°°ì—´ ê°™ì€ ê±´ ë°°ì—´ í¬ê¸°([extent](http://en.cppreference.com/w/cpp/types/extent)), cv í•œì •ì ì •ë³´ê°€ ìˆì—ˆì§€ë§Œ, decayëœ, ë‹¤ì‹œ ë§í•´, ì•½í•´ì§„ íƒ€ì…ì€ ì´ëŸ° ë¶€ì°¨ì ì¸ íƒ€ì… ì •ë³´ë¥¼ ì œê±°í•´ì„œ ë‹¤ë£¨ê¸° ì‰½ê²Œí•œë‹¤.

> ê·¸ë ‡ë‹¤ë©´ ì™œ `make_tuple`ì€ decayëœ íƒ€ì…ì„ ì“¸ê¹Œ? [ì´ SO ë¬¸ë‹µ](http://stackoverflow.com/questions/24557000/why-does-make-optional-decay-its-argument-type/24557628#24557628)ì—ì„œ ì˜ ì´í•´í•  ìˆ˜ ìˆë‹¤. ê°„ëµíˆ ì„¤ëª…í•˜ë©´, ì›ë˜ íƒ€ì…ì˜ ì •ë³´ë¥¼ ê·¸ëŒ€ë¡œ ì‚´ë ¤ì„œ íŠœí”Œë¡œ ë‹¤ë£¨ê¸°ê°€ í˜ë“¤ë•Œê°€ ìˆì–´ì„œì´ë‹¤. ë¹„ìŠ·í•œ ì˜ˆë¡œ `auto`ë¡œ íƒ€ì… ì¶”ë¡ í•  ë•Œë„ í•­ìƒ ê°’ìœ¼ë¡œë§Œ, ë˜ cv í•œì •ìëŠ” ìƒëµëœ ì±„ ì¶”ë¡ ëœë‹¤. `make_tuple` ë¿ë§Œ ì•„ë‹ˆë¼ `make_pair`ë„ decayëœ íƒ€ì…ì„ ì“´ë‹¤.

> ë˜ í•˜ë‚˜ ì‚¬ì†Œí•˜ì§€ë§Œ ì£¼ì˜í•  ì : `{...}`ë¡œ ìƒì„±í•œ í˜ì–´ë‚˜ íŠœí”Œì€ ì£¼ì–´ì§„ íƒ€ì…ì„ ê·¸ëŒ€ë¡œ ì“°ë¯€ë¡œ ì°¸ì¡°ì ì •ë³´ê°€ ì‚´ì•„ìˆë‹¤. ê·¸ë˜ì„œ `enumerate`ì—ì„œëŠ” `{...}`ë¡œ `PairType`ì„ ìƒì„±í•´ë„ ì˜ ë˜ì—ˆë‹¤. ê°„ë‹¨í•˜ê²Œ ë§í•˜ë©´ ì§€ê¸ˆ C++17 ê¸°ëŠ¥ë§Œ ì œëŒ€ë¡œ êµ¬í˜„ë˜ì–´ ìˆì–´ë„ ì´ëŸ° ì‚½ì§ˆì€ ì‚¬ë¼ì§„ë‹¤ëŠ” ì´ì•¼ê¸°ë‹¤.

ë‹¤í–‰íˆ ì£¼ì–´ì§„ íƒ€ì…ì„ decay ì‹œí‚¤ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ íŠœí”Œì„ ë§Œë“¤ì–´ì£¼ëŠ” í•¨ìˆ˜, `std::forward_as_tuple`ê°€ ìˆë‹¤. ì´ í•¨ìˆ˜ë¥¼ ì“°ë©´ ë¹„ë¡œì„œ ì™„ì„±í•  ìˆ˜ ìˆë‹¤.
<!-- [ì‹¤ì œ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„](https://github.com/llvm-mirror/libcxx/blob/master/include/tuple#L889)ì„ ë³´ë©´ `make_tuple`ê³¼ ë‹¤ë¥´ê²Œ ì…ë ¥ íƒ€ì…ì„ ê·¸ëŒ€ë¡œ ì“´ë‹¤. -->

{% highlight C++ %}
TupleType operator*() {
  // C++17ì—ì„œëŠ” ì•„ë˜ ì½”ë“œê°€ ì˜ ì‘ë™í•  ì˜ˆì •
  // return {*std::get<0>(its_), *std::get<1>(its_)};
  
  // std::refë¡œ ì°¸ì¡°ìë¥¼ ë¶™ì´ëŠ” ê²ƒì€ í”„ë½ì‹œ ë°˜ë³µìì—ì„œ ì»´íŒŒì¼ ì˜¤ë¥˜
  // return std::make_tuple(std::ref(*std::get<0>(its_)),
  //                        std::ref(*std::get<1>(its_)));

  // ì•„ë˜ ì½”ë“œëŠ” make_tupleì²˜ëŸ¼ íƒ€ì…ì„ decayí•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ì‚¬ìš©
  TupleType t{*std::get<0>(its_), *std::get<1>(its_)};
  return t;
}

TupleType operator*() {
  // ë¬µì‹œì ìœ¼ë¡œ TupleTypeìœ¼ë¡œ í˜•ë³€í™˜
  return std::forward_as_tuple(*std::get<0>(its_), *std::get<1>(its_));
}

decltype(auto) operator*() {
  // ë°˜ë“œì‹œ TupleTypeìœ¼ë¡œ í˜•ë³€í™˜í•´ì•¼ í•¨
  // ë¹ ëœ¨ë¦¬ë©´ dangling rvalue reference ë°œìƒí•  ìˆ˜ ìˆìŒ
  return static_cast<TupleType>(
      std::forward_as_tuple(*std::get<0>(its_),
                            *std::get<1>(its_)));
}
{% endhighlight %}
{% include code_caption.html caption="<code>zip_iterator::operator*</code>ì˜ ì—¬ëŸ¬ êµ¬í˜„ ì‹œë„" %}

	
All three forms serve different purposes - auto is always a value, auto&& is always a reference, and decltype(auto) can be either, depending on the initializer.

http://stackoverflow.com/questions/21369113/what-is-the-difference-between-auto-and-decltypeauto-when-returning-from-a-fun
